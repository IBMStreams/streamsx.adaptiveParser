<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<toolkitModel xmlns="http://www.ibm.com/xmlns/prod/streams/spl/toolkit" productVersion="4.2.0.2" xmlns:common="http://www.ibm.com/xmlns/prod/streams/spl/common" xmlns:ti="http://www.ibm.com/xmlns/prod/streams/spl/toolkitInfo" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <toolkit name="com.ibm.streamsx.adaptiveparser" requiredProductVersion="4.0" version="2.1">
    <description>
Support for multilevel hierarchical parsing based on [https://theboostcpplibraries.com/boost.spirit|Boost.Spirit] library.

Boost.Spirit is an object-oriented recursive-descent parser generator framework implemented using template meta-programming techniques.

Expression templates allow to approximate the syntax of Extended Backus-Normal Form (EBNF) completely in C++.

This toolkit provides automatic spirit parsing rules generation based on provided output tuple schema.

**Third-party libraries**
* This toolkit uses spirit, xpressive and other boost libraries&gt;.
    </description>
    <uriTable>
      <uri index="2" value="com.ibm.streamsx.adaptiveparser/AdaptiveParser"/>
      <uri index="1" value="com.ibm.streamsx.adaptiveparser/Types.spl"/>
    </uriTable>
    <namespace name="com.ibm.streamsx.adaptiveparser">
      <primitiveOp language="Cpp" modelUriIndex="2" name="AdaptiveParser" public="true">
        <description>
AdaptiveParser allows to parse any structured, semi-structured and unstructured input format accordingly to an output tuple schema.
Each primitive type attribute generates a mini parser, when grouped together they create a complex tuple parser. Tuple parsers can be nested.
Each collection type generates a collection parser that wraps a mini parser based on collection (key)/value type(s).

AdaptiveParser provides an ability to apply settings on any level: globally, partially or locally for a single attribute.

AdaptiveParser operator has two custom output functions: 
* Param applies parsing options only for top level attributes.
* ParamN applies parsing options for any nested level attributes.

One input port is allowed.
If there is only one blob/rstring attribute exists, it is taken as a data to be parsed. Otherwise dataAttr parameter should be applied.

Multiple output ports are allowed where each port defines an alternate parser.
If the last output port schema is identical to the input port schema then it is treated as an error port.	
      </description>
        <customLiterals name="Parsing">
          <value name="full"/>
          <value name="partial"/>
        </customLiterals>
        <customLiterals name="Skippers">
          <value name="none"/>
          <value name="blank"/>
          <value name="control"/>
          <value name="endl"/>
          <value name="punct"/>
          <value name="tab"/>
          <value name="whitespace"/>
        </customLiterals>
        <customLiterals name="Schemes">
          <value name="firstTypePaired"/>
          <value name="openAttrNamePaired"/>
          <value name="openTypeOrdered"/>
          <value name="openTypeUnordered"/>
          <value name="strictTypeOrdered"/>
        </customLiterals>
        <outputFunctions name="AdaptiveParserFS">
          <function name="AsIs" returnType="T">
            <description>Assign custom value to the output attribute.</description>
            <prototype>&lt;any T&gt; T AsIs(T v)</prototype>
            <parameter name="v" type="T"/>
          </function>
          <function name="Param" returnType="A">
            <description>
                Apply custom options to the top level attribute.

                The function has one tuple argument:
                	Param({delimiter="|", skipper=Skipper.blank, ...})
                The following parameters may be used:
				* attrFieldName: set alias for an attribute name (applicable when tupleScheme is 'openAttrNamePaired')
				* attrNameDelimiter: set delimiter for an attribute name (applicable when tupleScheme is 'openAttrNamePaired')
				* attrNameQuoted: expect an attribute name with quotes (applicable when tupleScheme is 'openAttrNamePaired')
				* base64Mode: set base64 decoding for the current string attribute
				* binaryMode: set binary encoding for the numeric attribute
				* cutCharsetDelim: set multiple delimiters the input will be searched first then parsed
				* cutStringDelim: set delimiter the input will be searched first then parsed
				* cutSkipper: set skipper the input will be searched first then parsed
				* defaultValue: apply default value for an optional attribute
				* delimiter: set delimiter for an attribute
				* escapeChar: set escaping character(s) for an attribute,
				* hexCharPrefix: set escaping character(s) for an attribute
				* globalAttrNameDelimiter: like attrNameDelimiter, apply to all nested levels (the current level is left unchanged)
				* globalAttrNameQuoted: like attrNameQuoted, apply to all nested levels (the current level is left unchaged)
				* globalDelimiter: like delimiter, apply to all nested levels (the current level is left unchanged)
				* globalEscapeChar: like escapeChar, apply to all nested levels (the current level is left unchanged)
				* globalSkipper: like skipper, apply to all nested levels (the current level is left unchanged)
				* globalTupleScheme: like tupleScheme, apply to all nested levels (the current level is left unchanged)
				* optional: an attribute can be skipped (taking a default value)
				* parseToState: an input field can be parsed to a state (maybe be used for skipCounter or just to drop a part of the input)
				* regexFilter: an attribute is filtered by regex expression and if fails the entire tuple parsing will be failed (use with an error port) 
				* quotedOptStrings: an attribute may have quotes (applicable only for strings)
				* quotedStrings: expect an attribute with quotes (applicable only for strings)
				* prefix: expect a prefix before the attribute (applicable only for primitive types)
				* suffix: expect a suffix after the attribute (applicable only for primitive types)
				* listPrefix: expect a prefix before the attribute (applicable only for lists/sets and inherited)
				* listSuffix: expect a suffix after the attribute (applicable only for lists/sets and inherited)
				* mapPrefix: expect a prefix before the attribute (applicable only for maps and inherited)
				* mapSuffix: expect a suffix after the attribute (applicable only for maps and inherited)
				* tuplePrefix: expect a prefix before the attribute (applicable only for tuples and inherited)
				* tupleSuffix: expect a suffix after the attribute (applicable only for tuples and inherited)
				* tsFormat: defines a string representation of timestamp (see the system man page for strptime)
				* tsToken: defines a character separator for epoch timestamp
				* bound: defines a bounded length type (not the value - e.g. 0uh) that parsed before the attribute (applicable only for strings)
				* skipCountAfter: sets a count of bytes to skip after the attribute
				* skipCountBefore: sets a count of bytes to skip before the attribute
				* skipChars: set character(s) to be skipped (applicable only for strings)
				* enumAliasesMap: defines alternate names for enum values (applicable only for enums)
				* skipper: set a skipper for all or subset of whitespaces to be skipped.
				* tupleScheme: an attribute data scheme (applicable only for tuples)
            </description>
            <prototype>&lt;any A, tuple T&gt; A Param(T options)</prototype>
            <parameter name="options" type="T"/>
          </function>
          <function name="Param" returnType="A">
            <description>
            Skip top level attribute and apply custom options to the next nested level attribute.

            The function has one anonymous '_' agrument (no options for the top level) and one tuple argument:
            	Param(_, {attr2level = ParamN({delimiter="|", skipper=Skipper.blank, ...})})
            </description>
            <prototype>&lt;any A, tuple T&gt; A Param(enum{_} options, T deepOptions)</prototype>
            <parameter name="options" type="enum { _ }"/>
            <parameter name="deepOptions" type="T"/>
          </function>
          <function name="Param" returnType="A">
            <description>
            Apply custom options to the top and the next nested level attributes.

            The function has two tuple arguments:
            	Param({delimiter="|", skipper=Skipper.none, ...}, {attr2level = ParamN({delimiter=",", skipper=Skipper.blank, ...})})
            </description>
            <prototype>&lt;any A, tuple T1, tuple T2&gt; A Param(T1 options, T2 deepOptions)</prototype>
            <parameter name="options" type="T1"/>
            <parameter name="deepOptions" type="T2"/>
          </function>
          <function name="ParamN" returnType="boolean">
            <description>
            Apply custom options to the current (non top level) attribute.

            The function has one tuple argument:
            	ParamN({delimiter="|", skipper=Skipper.none, ...})
            </description>
            <prototype>&lt;tuple T&gt; boolean ParamN(T options)</prototype>
            <parameter name="options" type="T"/>
          </function>
          <function name="ParamN" returnType="boolean">
            <description>
            Skip current (non top level) attribute and apply custom options to the next nested level attribute.

            The function has one anonymous '_' agrument (no options for the current level) and one tuple argument:
            	ParamN(_, {attr2level = ParamN({delimiter="|", skipper=Skipper.blank, ...})})
            </description>
            <prototype>&lt;tuple T&gt; boolean ParamN(enum{_} options, T deepOptions)</prototype>
            <parameter name="options" type="enum { _ }"/>
            <parameter name="deepOptions" type="T"/>
          </function>
          <function name="ParamN" returnType="boolean">
            <description>
            Apply custom options to the current (non top level) and the next nested attribute levels.

            The function has two tuple arguments:
            	ParamN({delimiter="|", skipper=Skipper.none, ...}, {attr2level = ParamN({delimiter=",", skipper=Skipper.blank, ...})})
            </description>
            <prototype>&lt;tuple T1, tuple T2&gt; boolean ParamN(T1 options, T2 deepOptions)</prototype>
            <parameter name="options" type="T1"/>
            <parameter name="deepOptions" type="T2"/>
          </function>
        </outputFunctions>
        <parametersDescription>Parameters allow to customize the global behavior of the operator. Most of the parameters can be applied also inside Param/ParamN functions.</parametersDescription>
        <parameter cardinality="1" expressionMode="Constant" name="allowEmpty" optional="true" type="boolean">
          <description>
        Allows empty value applying a default value instead.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="batch" optional="true" type="boolean">
          <description>
        Parse an input tuple as a bulk of data. Can submit multiple output tuples.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="binaryMode" optional="true" type="boolean">
          <description>
        All numeric parsers will parse the input as binary words.
        	valid in Param/ParamN: yes
        	non-global version: binaryMode
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="CustomLiteral" name="parsingMode" optional="true" type="Parsing">
          <description>
        Can be full or partial. In a partial mode the parsing succeeds when the whole output tuple is filled without checking if the input end is reached.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Attribute" name="dataAttr" optional="true" type="">
          <description>
        Sets the input attribute holding the data to parse.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="-1" expressionMode="Attribute" name="passAttrs" optional="true" type="">
          <description>
        Sets input attributes that should be copied to the output attributes. Those output attributes will not parse the input.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="comment" optional="true" type="rstring">
          <description>
        Sets the comment characters in the beginning of an input data. the input will be skipped.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Expression" name="explain" optional="true">
          <description>
        Prints to the output console additional information about the parsing.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="globalAttrNameQuoted" optional="true" type="boolean">
          <description>
        When tupleScheme is set to 'openAttrNamePaired' (key/value) expects keys to be quoted.
        	valid in Param/ParamN: yes
        	non-global version: attrNameQuoted
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="globalAttrNameDelimiter" optional="true" type="rstring">
          <description>
        When tupleScheme is set to 'openAttrNamePaired' (key/value) expects keys to be delimited.
	        valid in Param/ParamN: yes
	        non-global version: attrNameDelimiter
	        inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="globalDelimiter" optional="true" type="rstring">
          <description>
        A field delimiter - usually 1 or more characters.
        	valid in Param/ParamN: yes
        	non-global version: delimiter
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="globalEscapeChar" optional="true" type="rstring">
          <description>
        A field escape character.
        	valid in Param/ParamN: yes
        	non-global version: escapeChar
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="CustomLiteral" name="globalSkipper" optional="true" type="Skippers">
          <description>
        Set a skipper for all or subset of whitespaces to be skipped. Can be set to values:
        	none: whitespaces are not skipped and parsed as part of the input data
        	blank: all whitespaces are skipped except new lines
        	endl: only new lines are skipped
        	control: all control characters are skipped
        	punct: all punct characters are skipped
        	tab: only tabs are skipped
        	whitespace (default): all whitespaces are skipped

        	valid in Param/ParamN: yes
        	non-global version: skipper
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="CustomLiteral" name="globalTupleScheme" optional="true" type="Schemes">
          <description>
        An input data scheme. Can be set to values:
        	firstTypePaired: alternate parser - each tuple attribute tries to parse the input until one succeeds
        	openAttrNamePaired: tuple attributes parse the input as key/value pairs in any order, missing fields are allowed
        	openTypeOrdered: tuple attributes parse the input in a sequence, missing fields are allowed
        	openTypeUnordered: tuple attributes parse the input in any order, missing fields are allowed
        	strictTypeOrdered (default): tuple attributes parse the input in a sequence, all of them must be present 

        	valid in Param/ParamN: yes
        	non-global version: tupleScheme
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="CustomLiteral" name="tupleScheme" optional="true" type="Schemes">
          <description>
        An input data scheme. Can be set to values: the same as globalTupleScheme.
        	valid in Param/ParamN: yes
        	global version: globalTupleScheme
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="startFrom" optional="true" type="rstring">
          <description>
        Start parsing from the given character(s) skipping all the previous data from the beginning. 
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="listPrefix" optional="true" type="rstring">
          <description>
        Defines a preceding list/set character(s).
        	valid in Param/ParamN: yes
        	non-global version: listPrefix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="listSuffix" optional="true" type="rstring">
          <description>
        Defines a succeeding list/set character(s).
        	valid in Param/ParamN: yes
        	non-global version: listSuffix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="mapPrefix" optional="true" type="rstring">
          <description>
        Defines a preceding map character(s).
        	valid in Param/ParamN: yes
        	non-global version: mapPrefix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="mapSuffix" optional="true" type="rstring">
          <description>
        Defines a succeeding map character(s).
        	valid in Param/ParamN: yes
        	non-global version: mapSuffix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="tuplePrefix" optional="true" type="rstring">
          <description>
        Defines a preceding tuple character(s).
        	valid in Param/ParamN: yes
        	non-global version: tuplePrefix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="tupleSuffix" optional="true" type="rstring">
          <description>
        Defines a succeeding tuple character(s).
        	valid in Param/ParamN: yes
        	non-global version: tupleSuffix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="prefix" optional="true" type="rstring">
          <description>
        Defines a preceding attribute character(s).
        	valid in Param/ParamN: yes
        	non-global version: prefix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="suffix" optional="true" type="rstring">
          <description>
        Defines a succeeding attribute character(s).
        	valid in Param/ParamN: yes
        	non-global version: suffix
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="tsFormat" optional="true" type="rstring">
          <description>
        Defines a string representation of timestamp (see the system man page for strptime)
        	valid in Param/ParamN: yes
        	non-global version: tsFormat
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="tsToken" optional="true" type="rstring">
          <description>
        Defines a character separator for epoch timestamp.
        	valid in Param/ParamN: yes
        	non-global version: tsToken
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="quotedOptStrings" optional="true" type="boolean">
          <description>
        Allows string attributes to be optionally quoted.
        	valid in Param/ParamN: yes
        	non-global version: quotedOptStrings
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="quotedStrings" optional="true" type="boolean">
          <description>
        Expects string attributes to be quoted.
        	valid in Param/ParamN: yes
        	non-global version: quotedStrings
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="-1" expressionMode="Constant" name="undefined" optional="true" type="rstring">
          <description>
        Sets undefined value(s) for input fields.
        	valid in Param/ParamN: no
        	non-global version: no
        	inherited: yes
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="skipCountAfter" optional="true" type="uint32">
          <description>
        Sets number of characters to skip after the current attribute.
        	valid in Param/ParamN: yes
        	non-global version: skipCountAfter
        	inherited: no
        </description>
        </parameter>
        <parameter cardinality="1" expressionMode="Constant" name="skipCountBefore" optional="true" type="uint32">
          <description>
        Sets number of characters to skip before the current attribute.
        	valid in Param/ParamN: yes
        	non-global version: skipCountBefore
        	inherited: no
        </description>
        </parameter>
        <inputPort maxNumPorts="1" minNumPorts="1" optional="false" windowPunctInputMode="Oblivious">
          <description>The input data port. Logic can be applied, e.g. to update state.</description>
          <windowPolicy>NonWindowed</windowPolicy>
        </inputPort>
        <inputPort minNumPorts="0" optional="true" windowPunctInputMode="Oblivious">
          <description>The control input port(s) is only for logic section, e.g. to update state.</description>
          <windowPolicy>NonWindowed</windowPolicy>
        </inputPort>
        <outputPort expressionMode="AttributeFree" minNumPorts="0" optional="true" windowPunctOutputMode="Preserving">
          <description/>
        </outputPort>
      </primitiveOp>
      <compositeOp column="18" line="5" name="Skipper" potentialMain="true" public="true" uriIndex="1">
        <type column="10" line="7" name="Skippers" static="true" type="enum { none, blank, control, endl, punct, tab, whitespace }" uriIndex="1"/>
        <enumLiterals column="26" line="7" static="true" typeName="Skippers" uriIndex="1">
          <enum>none</enum>
          <enum>blank</enum>
          <enum>control</enum>
          <enum>endl</enum>
          <enum>punct</enum>
          <enum>tab</enum>
          <enum>whitespace</enum>
        </enumLiterals>
      </compositeOp>
      <compositeOp column="18" line="10" name="TupleScheme" potentialMain="true" public="true" uriIndex="1">
        <type column="10" line="12" name="Schemes" static="true" type="enum { firstTypePaired, openAttrNamePaired, openTypeOrdered, openTypeUnordered, strictTypeOrdered }" uriIndex="1"/>
        <enumLiterals column="25" line="12" static="true" typeName="Schemes" uriIndex="1">
          <enum>firstTypePaired</enum>
          <enum>openAttrNamePaired</enum>
          <enum>openTypeOrdered</enum>
          <enum>openTypeUnordered</enum>
          <enum>strictTypeOrdered</enum>
        </enumLiterals>
      </compositeOp>
      <type column="6" line="3" name="Anonymous" static="true" type="enum { _ }" uriIndex="1"/>
      <enumLiterals column="23" line="3" typeName="Anonymous" uriIndex="1">
        <enum>_</enum>
      </enumLiterals>
    </namespace>
    <sabFiles>
      <ti:include path="toolkit.xml" root="toolkitDir"/>
      <ti:include path="impl/java/lib/**" root="toolkitDir"/>
      <ti:include path="impl/java/bin/**" root="toolkitDir"/>
      <ti:include path="impl/bin/**" root="toolkitDir"/>
      <ti:include path="impl/lib/**" root="toolkitDir"/>
      <ti:include path="impl/nl/*.dat" root="toolkitDir"/>
      <ti:include path="etc/**" root="toolkitDir"/>
      <ti:include path="lib/**" root="toolkitDir"/>
      <ti:include path="nl/**" root="toolkitDir"/>
      <ti:include path="opt/**" root="toolkitDir"/>
    </sabFiles>
  </toolkit>

</toolkitModel>
