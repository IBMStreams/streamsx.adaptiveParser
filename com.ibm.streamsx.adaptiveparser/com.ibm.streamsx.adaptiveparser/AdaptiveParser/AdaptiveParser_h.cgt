#include <SPL/Runtime/Type/Enum.h>
#include <SPL/Runtime/Type/SPLType.h>
#include <SPL/Runtime/Function/TimeFunctions.h>
#include "time.h"

// #define STREAMS_BOOST_SPIRIT_QI_DEBUG

<%# [----- perl code -----]
BEGIN {*Type:: = *SPL::CodeGen::Type::};
use AdaptiveParserCommon;

my $parserOpt = {};
$parserOpt->{'attrNameAsPrefix'} = ($_ = $model->getParameterByName('attrNameAsPrefix')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'binaryMode'} = ($_ = $model->getParameterByName('binaryMode')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'quotedStrings'} = ($_ = $model->getParameterByName('quotedStrings')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'comment'} = ($_ = $model->getParameterByName('comment')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'attrNameDelimiter'} = ($_ = $model->getParameterByName('attrNameDelimiter')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'globalDelimiter'} = ($_ = $model->getParameterByName('globalDelimiter')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'globalSkipper'} = ($_ = $model->getParameterByName('globalSkipper')) ? AdaptiveParserCommon::getSkipper($_->getValueAt(0)->getSPLExpression()) : 'space';
$parserOpt->{'skipper'} = $parserOpt->{'skipperLast'} = $parserOpt->{'globalSkipper'};
$parserOpt->{'prefix'} = ($_ = $model->getParameterByName('prefix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'suffix'} = ($_ = $model->getParameterByName('suffix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'undefined'} = $model->getParameterByName('undefined');

my $oTupleCppType = 'oport0';
my $oTupleSplType = $model->getOutputPortAt(0)->getSPLTupleType();
my $oTupleSrcLocation = $model->getOutputPortAt(0)->getSourceLocation();
my $structs = [];

my $oAttrParams = $model->getOutputPortAt(0);
#my %oAttrNames = map { $_->getName() => ($_->hasAssignment() ? $_ : undef) } @{$model->getOutputPortAt(0)->getAttributes()};

my $STREAMS_FUSION_MAX_VECTOR_SIZE = 10;
AdaptiveParserCommon::buildStructs($oTupleSrcLocation, $oTupleCppType, $oTupleSplType, $structs, $oAttrParams, $parserOpt, \$STREAMS_FUSION_MAX_VECTOR_SIZE);

SPL::CodeGen::errorln("More than 50 attributes on the same level of tuple is not supported", $oTupleSrcLocation)  if ($STREAMS_FUSION_MAX_VECTOR_SIZE > 50);
# [----- perl code -----]%>

#define STREAMS_FUSION_MAX_VECTOR_SIZE <%=$STREAMS_FUSION_MAX_VECTOR_SIZE%>
//#define STREAMS_BOOST_FUSION_DONT_USE_PREPROCESSED_FILES

<% if ($STREAMS_FUSION_MAX_VECTOR_SIZE > 20) {%>
#define STREAMS_BOOST_MPL_LIMIT_LIST_SIZE <%=int($STREAMS_FUSION_MAX_VECTOR_SIZE / 10 + 0.99)*10%>
#define STREAMS_BOOST_MPL_LIMIT_VECTOR_SIZE STREAMS_BOOST_MPL_LIMIT_LIST_SIZE
#define STREAMS_BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
<%}%>

#include "Spirit.h"

<%SPL::CodeGen::headerPrologue($model);%>
<%my $baseRule = 'oport0_base';%>

using namespace ::ext;

typedef MY_BASE_OPERATOR::OPort0Type oport0;

const std::string dq = "\"";

template <typename Iterator>
struct TupleParserGrammar : qi::grammar<Iterator, oport0(bool&)> {
    TupleParserGrammar() : TupleParserGrammar::base_type(<%=$baseRule%>) {

<%# [----- perl code -----]

for my $symbols (values %{$structs->[-1]->{'symbols'}}) {
print qq(
		$symbols->{'enumName'}.add @{$symbols->{'enumValues'}} ;
);
}
 
if ($parserOpt->{'undefined'}) {
	my $undefValue;
	my @undefinedValues = map { $_->getSPLExpression() ne '""' ? '('.$_->getSPLExpression().', qi::unused)' : () } @{$parserOpt->{'undefined'}->getValues()};
	SPL::CodeGen::errorln("Empty values cannot be assigned to parameter 'undefined'", $oTupleSrcLocation)  unless (@undefinedValues);

print qq(
		undefined.add @undefinedValues;
);

}

foreach my $struct (@{$structs}) {
if (scalar %{$struct}) {
	my $skipper = $struct->{'skipper'} ? "skip($struct->{'skipper'})" : 'lexeme';
	my $operator = $struct->{'attrNameAsPrefix'} ? ' / ' : ' >> ';
	my $rule = join($operator, @{$struct->{'ruleBody'}});
	$rule = $skipper."[$rule]";
	$rule .= " >> eps" if ($struct->{'size'} <= 1); # patch for single element tuple
	$rule = "!lit($parserOpt->{'comment'})[_r1 = val(true)] >> eps[_r1 = val(false)] >> $rule" if ($struct->{'cppType'} eq 'oport0' && $parserOpt->{'comment'});
print qq(
		$struct->{'ruleName'} %= $rule;
);
}
}
# [----- perl code -----]%>
 
	timestamp = skip(blank)[eps] >> long_[bind(&ts::setSeconds,_val,_1)] >> lit(_r1) >> uint_[bind(&ts::setNanoSeconds,_val,_1*1000)];
	timestampS = skip(blank)[eps] >> "(" >> long_[bind(&ts::setSeconds,_val,_1)] >> "," >> uint_[bind(&ts::setNanoSeconds,_val,_1)] >> "," >> int_[bind(&ts::setMachineId,_val,_1)] >> ")";

//    	<%=$baseRule%>.name("oport0");

//		on_error<fail> (<%=$baseRule%>, std::cout
//				<< val("Error! Expecting ")
//				<< _4                               // what failed?
//				<< val("\nhere:")
//				<< std::endl
//				<< construct<std::string>(_3, _2)   // iterators to error-pos, end
//				<< std::endl
//		);

//		STREAMS_BOOST_SPIRIT_DEBUG_NODE(<%=$baseRule%>);
    }

private:

//	const qi::real_parser<double, qi::strict_ureal_policies<double> > double_;
//	const qi::real_parser<float, qi::strict_ureal_policies<float> > float_;
 
	boolean_ boolean;
	dummy_ dummy;
	qi::symbols<char, qi::unused_type> undefined;

	qi::rule<Iterator,  ts(std::string)> timestamp;
	qi::rule<Iterator,  ts()> timestampS;
    
<%# [----- perl code -----]

for my $symbols (values %{$structs->[-1]->{'symbols'}}) {
print qq(
	qi::symbols<char, $symbols->{'enumType'}> $symbols->{'enumName'};
);
}

foreach my $struct (@{$structs}) {
	if (scalar %{$struct} && $struct->{'cppType'} ne 'oport0') {
print qq(
	qi::rule<Iterator, $struct->{'cppType'}()> $struct->{'ruleName'};
);
	}
}
# [----- perl code -----]%>

    qi::rule<Iterator, oport0(bool&)> oport0_base;

};

class MY_OPERATOR : public MY_BASE_OPERATOR {
public:
  MY_OPERATOR();
  virtual ~MY_OPERATOR(); 

  void allPortsReady(); 
  void prepareToShutdown(); 

  void process(Tuple const & tuple, uint32_t port);
  void process(Punctuation const & punct, uint32_t port);

  inline void setInputIterators(const blob & raw, charPtr & iter_start, charPtr & iter_end) {
	iter_start = reinterpret_cast<charPtr>(raw.getData());
	iter_end = reinterpret_cast<charPtr>(raw.getData() + raw.getSize());
  }
  
  inline void setInputIterators(const std::string & row, charPtr & iter_start, charPtr & iter_end) {
	iter_start = row.data();
	iter_end = iter_start + row.size();
  }

private:
	TupleParserGrammar<charPtr> tupleParser;
}; 

<%SPL::CodeGen::headerEpilogue($model);%>

typedef <%=$model->getOutputPortAt(0)->getCppTupleType()%> oport0;

<%# [----- perl code -----]
if (defined($structs->[-1]->{'xml'})) {
	my @xmlDefs = values %{$structs->[-1]->{'xml'}};
	
	foreach my $xml (@xmlDefs) {
print qq(
	$xml
);
	}

}
 
foreach my $struct (@{$structs}) {
print qq(
	$struct->{'traits'}
	$struct->{'extension'}
);
}
# [----- perl code -----]%>
