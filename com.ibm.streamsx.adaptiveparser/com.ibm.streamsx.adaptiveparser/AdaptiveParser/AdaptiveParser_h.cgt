#include <SPL/Runtime/Type/Enum.h>
#include <SPL/Runtime/Type/SPLType.h>
#include <SPL/Runtime/Function/TimeFunctions.h>
#include "time.h"

// #define STREAMS_BOOST_SPIRIT_QI_DEBUG

<%# [----- perl code -----]
BEGIN {*Type:: = *SPL::CodeGen::Type::};
use AdaptiveParserCommon;

my $batch = ($_ = $model->getParameterByName('batch')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
my $startFrom = ($_ = $model->getParameterByName('startFrom')) ? $_->getValueAt(0)->getSPLExpression() : '';

my $parserOpt = {};
$parserOpt->{'allowEmpty'} = ($_ = $model->getParameterByName('allowEmpty')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'binaryMode'} = ($_ = $model->getParameterByName('binaryMode')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'globalAttrNameAsPrefix'} = ($_ = $model->getParameterByName('globalAttrNameAsPrefix')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'globalAttrNameQuoted'} = ($_ = $model->getParameterByName('globalAttrNameQuoted')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'quotedStrings'} = ($_ = $model->getParameterByName('quotedStrings')) ? $_->getValueAt(0)->getSPLExpression() eq 'true' : 0;
$parserOpt->{'comment'} = ($_ = $model->getParameterByName('comment')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'globalAttrNameDelimiter'} = ($_ = $model->getParameterByName('globalAttrNameDelimiter')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'globalDelimiter'} = ($_ = $model->getParameterByName('globalDelimiter')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'globalEscapeChar'} = ($_ = $model->getParameterByName('globalEscapeChar')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'globalSkipper'} = ($_ = $model->getParameterByName('globalSkipper')) ? AdaptiveParserCommon::getSkipper($_->getValueAt(0)->getSPLExpression()) : 'space';
$parserOpt->{'skipper'} = $parserOpt->{'skipperLast'} = $parserOpt->{'globalSkipper'};
$parserOpt->{'listPrefix'} = ($_ = $model->getParameterByName('listPrefix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'listSuffix'} = ($_ = $model->getParameterByName('listSuffix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'mapPrefix'} = ($_ = $model->getParameterByName('mapPrefix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'mapSuffix'} = ($_ = $model->getParameterByName('mapSuffix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'tuplePrefix'} = ($_ = $model->getParameterByName('tuplePrefix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'tupleSuffix'} = ($_ = $model->getParameterByName('tupleSuffix')) ? $_->getValueAt(0)->getSPLExpression() : '';
$parserOpt->{'undefined'} = $model->getParameterByName('undefined');

my $oTupleCppType = 'oport0';
my $oTupleSplType = $model->getOutputPortAt(0)->getSPLTupleType();
my $oTupleSrcLocation = $model->getOutputPortAt(0)->getSourceLocation();
my $structs = [];

my $oAttrParams = $model->getOutputPortAt(0);
#my %oAttrNames = map { $_->getName() => ($_->hasAssignment() ? $_ : undef) } @{$model->getOutputPortAt(0)->getAttributes()};

my $STREAMS_FUSION_MAX_VECTOR_SIZE = 10;
AdaptiveParserCommon::buildStructs($oTupleSrcLocation, $oTupleCppType, $oTupleSplType, $structs, $oAttrParams, $parserOpt, \$STREAMS_FUSION_MAX_VECTOR_SIZE);

SPL::CodeGen::errorln("More than 50 attributes on the same level of tuple is not supported", $oTupleSrcLocation)  if ($STREAMS_FUSION_MAX_VECTOR_SIZE > 50);
# [----- perl code -----]%>

#define STREAMS_FUSION_MAX_VECTOR_SIZE <%=$STREAMS_FUSION_MAX_VECTOR_SIZE%>
//#define STREAMS_BOOST_FUSION_DONT_USE_PREPROCESSED_FILES

<% if ($STREAMS_FUSION_MAX_VECTOR_SIZE > 20) {%>
#define STREAMS_BOOST_MPL_LIMIT_LIST_SIZE <%=int($STREAMS_FUSION_MAX_VECTOR_SIZE / 10 + 0.99)*10%>
#define STREAMS_BOOST_MPL_LIMIT_VECTOR_SIZE STREAMS_BOOST_MPL_LIMIT_LIST_SIZE
#define STREAMS_BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
<%}%>

#include "Spirit.h"

<%SPL::CodeGen::headerPrologue($model);%>
<%my $baseRule = 'oport0_base';%>

using namespace ::ext;

typedef MY_BASE_OPERATOR::OPort0Type oport0;

const std::string dq = "\"";

template <typename Iterator>
struct TupleParserGrammar : qi::grammar<Iterator, oport0(bool&)> {
    TupleParserGrammar() : TupleParserGrammar::base_type(<%=$baseRule%>) {

<%# [----- perl code -----]

for my $symbols (values %{$structs->[-1]->{'symbols'}}) {
print qq(
		$symbols->{'enumName'}.add @{$symbols->{'enumValues'}} ;
);
}
 
if ($parserOpt->{'undefined'}) {
	my $undefValue;
	my @undefinedValues = map { $_->getSPLExpression() ne '""' ? '('.$_->getSPLExpression().', qi::unused)' : () } @{$parserOpt->{'undefined'}->getValues()};
	SPL::CodeGen::errorln("Empty values cannot be assigned to parameter 'undefined'", $oTupleSrcLocation)  unless (@undefinedValues);

print qq(
		undefined.add @undefinedValues;
);

}

foreach my $struct (@{$structs}) {
if (scalar %{$struct}) {
	my $skipper = $struct->{'skipper'} ? "skip($struct->{'skipper'})" : 'lexeme';
#my $assign = $struct->{'size'} == 1 ? '%=' : '%=';
	my $operator = $struct->{'globalAttrNameAsPrefix'} ? ' / ' : ' >> ';
	my $rule = join($operator, @{$struct->{'ruleBody'}});
	$rule = "lit($parserOpt->{'tuplePrefix'}) >> $rule" if ($struct->{'cppType'} eq 'oport0' && $parserOpt->{'tuplePrefix'});
	if ($struct->{'cppType'} eq 'oport0' && $parserOpt->{'tupleSuffix'}) {
		$rule = "$rule >> lit($parserOpt->{'tupleSuffix'})" if ($batch);
		$rule = "reparse2(byte_ - (lit($parserOpt->{'tupleSuffix'}) | eoi))[$rule] >> lit($parserOpt->{'tupleSuffix'})" unless ($batch);
	}
	$rule = "eps >> $rule" if ($struct->{'size'} <= 1); # patch for single element tuple
	$rule = $skipper."[$rule]";
	$rule = "skip(byte_ - lit($startFrom))[eps] >> $rule" if ($struct->{'cppType'} eq 'oport0' && $startFrom);
	$rule = "!lit($parserOpt->{'comment'})[_r1 = val(true)] >> eps[_r1 = val(false)] >> $rule" if ($struct->{'cppType'} eq 'oport0' && $parserOpt->{'comment'});
print qq(
		$struct->{'ruleName'} %= $rule;
);
}
}
# [----- perl code -----]%>

	timestamp = skip(blank)[eps] >> long_[bind(&ts::setSeconds,_val,_1)] >> lit(_r1) >> uint_[bind(&ts::setNanoSeconds,_val,_1*1000)];
	timestampS = skip(blank)[eps] >> "(" >> long_[bind(&ts::setSeconds,_val,_1)] >> "," >> uint_[bind(&ts::setNanoSeconds,_val,_1)] >> "," >> int_[bind(&ts::setMachineId,_val,_1)] >> ")";

//    	<%=$baseRule%>.name("oport0");

//		on_error<fail> (<%=$baseRule%>, std::cout
//				<< val("Error! Expecting ")
//				<< _4                               // what failed?
//				<< val("\nhere:")
//				<< std::endl
//				<< construct<std::string>(_3, _2)   // iterators to error-pos, end
//				<< std::endl
//		);

//		STREAMS_BOOST_SPIRIT_DEBUG_NODE(<%=$baseRule%>);
    }

private:

//	const qi::real_parser<double, qi::strict_ureal_policies<double> > double_;
//	const qi::real_parser<float, qi::strict_ureal_policies<float> > float_;
 
	boolean_ boolean;
	dummy_ dummy;
	qi::symbols<char, qi::unused_type> undefined;

	qi::rule<Iterator,  ts(std::string)> timestamp;
	qi::rule<Iterator,  ts()> timestampS;
    
<%# [----- perl code -----]

for my $symbols (values %{$structs->[-1]->{'symbols'}}) {
print qq(
	qi::symbols<char, $symbols->{'enumType'}> $symbols->{'enumName'};
);
}

foreach my $struct (@{$structs}) {
	if (scalar %{$struct} && $struct->{'cppType'} ne 'oport0') {
print qq(
	qi::rule<Iterator, $struct->{'cppType'}()> $struct->{'ruleName'};
);
	}
}
# [----- perl code -----]%>

    qi::rule<Iterator, oport0(bool&)> oport0_base;

};

class MY_OPERATOR : public MY_BASE_OPERATOR {
public:
  MY_OPERATOR();
  virtual ~MY_OPERATOR(); 

  void allPortsReady(); 
  void prepareToShutdown(); 

  void process(Tuple const & tuple, uint32_t port);
  void process(Punctuation const & punct, uint32_t port);

  inline void setInputIterators(const blob & raw, charPtr & iter_start, charPtr & iter_end) {
	iter_start = reinterpret_cast<charPtr>(raw.getData());
	iter_end = reinterpret_cast<charPtr>(raw.getData() + raw.getSize());
  }
  
  inline void setInputIterators(const std::string & row, charPtr & iter_start, charPtr & iter_end) {
	iter_start = row.data();
	iter_end = iter_start + row.size();
  }

private:
	TupleParserGrammar<charPtr> tupleParser;
}; 

<%SPL::CodeGen::headerEpilogue($model);%>

typedef <%=$model->getOutputPortAt(0)->getCppTupleType()%> oport0;

<%# [----- perl code -----]
if (defined($structs->[-1]->{'enum'})) {
	my @enumDefs = values %{$structs->[-1]->{'enum'}};
	
	foreach my $cppType (@enumDefs) {
print qq(
	namespace streams_boost { namespace spirit { namespace traits {
	template <typename Iterator>
	struct assign_to_attribute_from_iterators<$cppType, Iterator> {
		static void call(Iterator const& first, Iterator const& last, $cppType & attr) {
			const std::string enumValue(first,last);
			if(attr.isValidValue(enumValue)) {
				attr = enumValue;
			}
			else {
				SPLAPPLOG(L_ERROR, enumValue << " is not part of $cppType enum.", "AdaptiveParser");
			}
		}
	};
	
//	template <>
//	struct assign_to_attribute_from_value<std::string, $cppType> {
//		static void call(std::string & enumValue, $cppType & attr) {
//			std::cout << enumValue << std::endl;
//			if(attr.isValidValue(enumValue)) {
//				attr = enumValue;
//			}
//		}
//	};
	}}}
);
	}

}

if (defined($structs->[-1]->{'xml'})) {
	my @xmlDefs = values %{$structs->[-1]->{'xml'}};
	
	foreach my $cppType (@xmlDefs) {
print qq(
	namespace streams_boost { namespace spirit { namespace traits {
	template <typename Iterator>
	struct assign_to_attribute_from_iterators<$cppType, Iterator> {
		static void call(Iterator const& first, Iterator const& last, $cppType & attr) {
			attr = $cppType( SPL::rstring(first,last));
		}
	};
	}}}
);
	}

}

if (defined($structs->[-1]->{'tuple'})) {
	my @tupleDefs = keys %{$structs->[-1]->{'tuple'}};
	my @attrDefs = values %{$structs->[-1]->{'tuple'}};
	
	for (my $i = 0; $i < @tupleDefs; $i++) {
		my $cppTupleType = $tupleDefs[$i];
		my $cppAttrType = "$cppTupleType\::$attrDefs[$i]\_type";
print qq(
//	namespace streams_boost { namespace spirit { namespace traits {
//	    template <>
//	    struct transform_attribute<$cppTupleType, $cppAttrType, qi::domain>
//	    {
//	        typedef $cppAttrType & type;
//	        static $cppAttrType & pre($cppTupleType & tuple1) {
//	        	return tuple1.get_$attrDefs[$i]();
//	        }
//
//	        static void post($cppTupleType &, $cppAttrType const&) {}
//	        static void fail($cppTupleType &) {}
//	    };
//	}}}
);
	}

}

foreach my $struct (@{$structs}) {
print qq(
	$struct->{'traits'}
	$struct->{'extension'}
);
}
# [----- perl code -----]%>
